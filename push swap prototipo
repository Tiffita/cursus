#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <limits.h> necesitos numeros min y max

// definir listas, revisar listas dobles ?
typedef struct Node {
    int data;
    struct Node *next;
} Node;

// prototipos ( ver bien despues)
Node *createNode(int value);
void push(Node **top, int value);
int pop(Node **top);
bool isEmpty(Node *top);
void freeStack(Node **top);
void split(char *input, Node **top) // modificar split , const char ?)
void printOperations(int *operations, int count);

// hacer instrucciones combinarlas con un ft_printf ? o write directo?
void swap(Node **stack);
void rotate(Node **stack);
void reverseRotate(Node **stack);
void pushAtoB(Node **stack_a, Node **stack_b);

int main(int argc, char *argv[]) {
   
    Node *stack_a = NULL;

   
    if (argc != 2) {
        ft_printf("Error\n");
        return (1);
    }

    // iniciar stack a , modificar split
    ft_split(argv[1], &stack_a);

    // actualizaciones del stack
    int *operations = (int*)malloc(sizeof(int) * 1000);
    int opCount = 0;

    //  algoritmo a hacer, llamar a funcion del algoritmo
    

    // printf de instrucciones
    printOperations(operations, opCount);

    // hacer los free del split en caso de que diferentes av o string
    int i = 0;
    while (argv[i]) 
    {
        free(argv[i]);
        i++;
    }
    free(argv); 
    freeStack(&stack_a);
    free(operations);

    return (0);
}

// crear nuevo nodo
Node *createNode(int value) {
    Node *newNode = (Node*)malloc(sizeof(Node));
    if (newNode) {
        newNode->data = value;
        newNode->next = NULL;
    }
    return (newNode);
}

// pushear un nodo al stack
void push(Node **top, int value) {
    Node *newNode = createNode(value);
    if (newNode) {
        newNode->next = *top;
        *top = newNode;
    }
}

// popear un nodo del stack
int pop(Node **top) {
    if (isEmpty(*top)) {
        printf("Error: Stack is empty\n");
        return INT_MIN;
    }
    int data = (*top)->data;
    Node *temp = *top;
    *top = (*top)->next;
    free(temp);
    return data;
}

//  ver si el stack esta vacio
int isEmpty(Node *top) {
    return top == NULL ? 1 : 0;
}

// hacer free del stack
void freeStack(Node **top) {
    while (!isEmpty(*top)) {
        pop(top);
    }
}

// split para recibir los av
void split(char *input, Node **top) {
    char *token = ft_split(input, " ");
    while (token != NULL) {
        push(top, ft_atoi(token));
        token = ft_split(NULL, " ");
    }
}

// ft_printf de las instrucciones
void printOperations(int *operations, int count) {
    ft_printf("List of operations:\n");
    i = 0;
    while (i < count)
    }
       i++;
       ft_printf("%d ", operations[i]);
    }
    ft_printf("\n");
}
void printOperations(Node *operations) {
    while (operations != NULL) {
        char buffer[20];  
        ft_itoa(operations->data, buffer, 10);  
        write(1, buffer, ft_strlen(buffer));  
        write(1, " ", 1);  
        operations = operations->next;  
    }
    write(1, "\n", 1);  
}

// instrucciones
void swap(Node **stack) {
    
}

void rotate(Node **stack) {
   
}

void reverseRotate(Node **stack) {
    
}

void pushAtoB(Node **stack_a, Node **stack_b) {
   
}
